/*
 *AMARACHI IWUH
 *1001122585
 */

package distance_vector_routing;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.table.DefaultTableModel;
import java.util.Collections;
import javax.swing.JOptionPane;
import java.awt.Font;

/**
 *Tables_GUI.java
 * 
 * This class runs the Distance vector routing algorithm 
 * and displays the updated tables on a JFrame GUI. 
 * The program begins by clicking on the LOAD TABLE button in the 
 * displayed GUI. Clicking the RUN button will run the Distance Vector 
 * Algorithm and the tables of the updated nodes can be observed 
 * using the drop-down menu Nodes on the far-left of the JFrame
 */

public class Tables_GUI extends javax.swing.JFrame {

    /**
     * Global variables
     */
    int row = 0;                        //inidcates total number of nodes in the network
    int initial = 1;                    //when initial == 1; then the routing algorithm has not been run yet
                                        //when initial == 0; the algorithm is running and the tables are updated
    int step = 0;                       //keeps track of each iteration of the algorithm
    int count =0;
    ArrayList<Integer> bellmanFord;     //stores the added cost and distanc pair
    Object[][] originalData;            //stores the textfile 
    
    //Object arrays used throughout the program to update and display information
    Object[] temp1 = {"1", "16", "16", "16", "16", "16", "16"};
    Object[] temp2 = {"2", "16", "16", "16", "16", "16", "16"};
    Object[] temp3 = {"3", "16", "16", "16", "16", "16", "16"};
    Object[] temp4 = {"4", "16", "16", "16", "16", "16", "16"};
    Object[] temp5 = {"5", "16", "16", "16", "16", "16", "16"};
    Object[] temp6 = {"6", "16", "16", "16", "16", "16", "16"};
    String columnNames [];
    Object[] tableLines;
    Object[] updatedTable1 = {"1", "16", "16", "16", "16", "16", "16"};
    Object[] updatedTable2 = {"2", "16", "16", "16", "16", "16", "16"};
    Object[] updatedTable3 = {"3", "16", "16", "16", "16", "16", "16"};
    Object[] updatedTable4 = {"4", "16", "16", "16", "16", "16", "16"};
    Object[] updatedTable5 = {"5", "16", "16", "16", "16", "16", "16"};
    Object[] updatedTable6 = {"6", "16", "16", "16", "16", "16", "16"};
    Object [][] updatedTables = {updatedTable1, updatedTable2, updatedTable3, updatedTable4, updatedTable5, updatedTable6};
    Object[] initialTable1 = {"16", "16", "16", "16", "16", "16"};
    Object[] initialTable2 = {"16", "16", "16", "16", "16", "16"};
    Object[] initialTable3 = {"16", "16", "16", "16", "16", "16"};
    Object[] initialTable4 = {"16", "16", "16", "16", "16", "16"};
    Object[] initialTable5 = {"16", "16", "16", "16", "16", "16"};
    Object[] initialTable6 = {"16", "16", "16", "16", "16", "16"};
    Object [][] initialTable = {initialTable1, initialTable2, initialTable3, initialTable4, initialTable5, initialTable6};
    List<List<Integer>> neighbours;
    
    
    public Tables_GUI() throws FileNotFoundException, IOException { 
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        run = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        stepBystep = new javax.swing.JButton();
        loadTable = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        nodeMenu = new javax.swing.JMenu();
        Node1 = new javax.swing.JMenuItem();
        Node2 = new javax.swing.JMenuItem();
        Node3 = new javax.swing.JMenuItem();
        Node4 = new javax.swing.JMenuItem();
        Node5 = new javax.swing.JMenuItem();
        Node6 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        run.setText("RUN");
        run.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runActionPerformed(evt);
            }
        });

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        jScrollPane1.setViewportView(jTable1);

        stepBystep.setText("STEP-BY-STEP");
        stepBystep.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stepBystepActionPerformed(evt);
            }
        });

        loadTable.setText("LOAD TABLE");
        loadTable.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadTableActionPerformed(evt);
            }
        });

        nodeMenu.setText("Nodes");

        Node1.setText("node 1");
        Node1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node1ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node1);

        Node2.setText("node 2");
        Node2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node2ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node2);

        Node3.setText("node 3");
        Node3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node3ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node3);

        Node4.setText("node 4");
        Node4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node4ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node4);

        Node5.setText("node 5");
        Node5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node5ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node5);

        Node6.setText("node 6");
        Node6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Node6ActionPerformed(evt);
            }
        });
        nodeMenu.add(Node6);

        jMenuBar1.add(nodeMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(73, 73, 73)
                .addComponent(loadTable)
                .addGap(37, 37, 37)
                .addComponent(run)
                .addGap(28, 28, 28)
                .addComponent(stepBystep)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(15, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 409, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(run)
                    .addComponent(stepBystep)
                    .addComponent(loadTable))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(46, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**************************************************************************
     * runActionPerformed(EventListener)
     * 
     * This function runs the distance vector routing algorithm to find
     * the shortest path from each node to every other node.
     *************************************************************************/
    
    private void runActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runActionPerformed

        dvr();
    }//GEN-LAST:event_runActionPerformed

    /**************************************************************************
     * Node4ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 4 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node4ActionPerformed

        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);       //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable4[1] == "16"){
            model.addRow(temp1);
            model.addRow(temp2);
            model.addRow(temp3);
            model.addRow(updatedTable4);    //this is displays the updated information for node 4
            model.addRow(temp5);
            model.addRow(temp6);
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
        
        
    }//GEN-LAST:event_Node4ActionPerformed
     /**************************************************************************
     * Node1ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 1 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node1ActionPerformed

        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable1[1] == "16"){
            
            model.addRow(updatedTable1); //this is displays the updated information for node 1
            model.addRow(temp2);
            model.addRow(temp3);
            model.addRow(temp4);
            model.addRow(temp5);
            model.addRow(temp6);
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
    }//GEN-LAST:event_Node1ActionPerformed

    /**************************************************************************
     * Node2ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 2 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node2ActionPerformed
    
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable2[1] == "16"){
            model.addRow(temp1);
            model.addRow(updatedTable2); //this is displays the updated information for node 2
            model.addRow(temp3);
            model.addRow(temp4);
            model.addRow(temp5);
            model.addRow(temp6);
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
    }//GEN-LAST:event_Node2ActionPerformed

    /**************************************************************************
     * Node3ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 3 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node3ActionPerformed
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable3[1] == "16"){
            model.addRow(temp1);
            model.addRow(temp2);
            model.addRow(updatedTable3);    //this is displays the updated information for node 3
            model.addRow(temp4);
            model.addRow(temp5);
            model.addRow(temp6);
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
    }//GEN-LAST:event_Node3ActionPerformed

    /**************************************************************************
     * Node5ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 5 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node5ActionPerformed
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable5[1] == "16"){
            model.addRow(temp1);
            model.addRow(temp2);
            model.addRow(temp3);
            model.addRow(temp4);
            model.addRow(updatedTable5);    //this is displays the updated information for node 5
            model.addRow(temp6);
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
    }//GEN-LAST:event_Node5ActionPerformed

    /**************************************************************************
     * Node6ActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 6 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void Node6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Node6ActionPerformed

        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        
        //if the algorithm has been run, the table displays the default satate of all the nodes
        //16 == INFINITY
        if (initial == 1 || updatedTable6[1] == "16"){
            model.addRow(temp1);
            model.addRow(temp2);
            model.addRow(temp3);
            model.addRow(temp4);
            model.addRow(temp5);
            model.addRow(updatedTable6);    //this is displays the updated information for node 6
        }
        
        //if the algorith has been run, the updated tables for each node will be displayed
        else{
            for (int i=0; i< row; i++){
                model.addRow(updatedTables[i]);
            }
        }
    }//GEN-LAST:event_Node6ActionPerformed

    /**************************************************************************
     * stepBystepActionPerformed(EventListener)
     * 
     * This function displays the routing table of Node 6 by displaying the current
     * routing information of each node, row-by-row
     *************************************************************************/
    private void stepBystepActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stepBystepActionPerformed

        String message = "Simulation has attained a stable state\n";
        int i, dest, cost, dist;
        initial=0;
        if (step >= row){
            JOptionPane.showMessageDialog(null, message + "Cycles: "+ (count+row), "Notice", JOptionPane.WARNING_MESSAGE);
        }
        
        else{
            for (dest =1; dest<= row; dest++){
                bellmanFord = new ArrayList<Integer>();
                if((step + 1) == dest){
                       System.out.println("Here" + (step+1) + dest);
                       bellmanFord.add(0); 
                       
                    }
                count++;
                
                for (i=0; i< neighbours.get(step).size(); i++){
                    System.out.print("node " + step);
                    System.out.print(" neighbour " + neighbours.get(step).get(i));
                    cost = Integer.parseInt((String)updatedTables[step][neighbours.get(step).get(i)]);
                    System.out.println("cost " + cost);
                    //dist = Integer.parseInt((String)originalData[neighbours.get(node).get(i)][dest]);
                    dist = Integer.parseInt((String)initialTable[neighbours.get(step).get(i) -1][dest-1]);
                    System.out.print(" neighbour " + (neighbours.get(step).get(i)-1));
                    System.out.print("dest " + (dest-1));
                    System.out.println(" dist " + dist);
                    bellmanFord.add(cost + dist);
                    System.out.println();
                    System.out.println();
                }
                
                int min = Collections.min(bellmanFord);
                updatedTables[step][dest] = Integer.toString(min);
                System.out.println("min" + min);
                
            }
        }
        step++;
    }//GEN-LAST:event_stepBystepActionPerformed

    private void loadTableActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadTableActionPerformed
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        try {
            // TODO add your handling code here:
            readFile();
        } catch (IOException ex) {
            Logger.getLogger(Tables_GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        model.addRow(updatedTable1); //this is displays the updated information for node 1
            model.addRow(temp2);
            model.addRow(temp3);
            model.addRow(temp4);
            model.addRow(temp5);
            model.addRow(temp6);
        
    }//GEN-LAST:event_loadTableActionPerformed

    public void readFile() throws FileNotFoundException, IOException{
        int i,j;
        File file = new File("graph.txt");
        BufferedReader br = new BufferedReader(new FileReader(file));
        tableLines = br.lines().toArray();
        
        String line, name;
        Integer [] num = new Integer[tableLines.length*2];
        
        for (i=0,j=0; i<tableLines.length*2; i=i+2, j++){
            //System.out.println(i);
            String l = tableLines[j].toString().trim();
            String[] dataRow = l.split(" ");
            num[i] = Integer.parseInt(dataRow[0]);
            num[i+1] = Integer.parseInt(dataRow[1]);
        }
        //System.out.println("row: " + Collections.max(Arrays.asList(num)));
        row = Collections.max(Arrays.asList(num));
        
        System.out.print(row);
        
        columnNames = new String [row+1];
        
        columnNames[0] = " ";
        for(i=1; i < row+1; i++){
            name = Integer.toString(i);
            columnNames[i] = name;
        }
        populate();
        populate_neighbours();
    }
    
    public void populate(){
        int i;
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setColumnIdentifiers(columnNames);
        originalData = new Object[tableLines.length][3];
        //initialTable = new Object[6][6];
        for( i = 0; i < tableLines.length; i++)
            {
                String l = tableLines[i].toString().trim();
                String[] dataRow = l.split(" ");
                originalData[i] = dataRow;
                switch (dataRow[0]) {
                    case "1":
                        updatedTable1[1] = "0";
                        updatedTable1[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[0][0] = "0";
                        initialTable[0][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                    case "2":
                        updatedTable2[2] = "0";
                        updatedTable2[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[1][1] = "0";
                        initialTable[1][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                    case "3":
                        updatedTable3[3] = "0";
                        updatedTable3[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[2][2] = "0";
                        initialTable[2][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                    case "4":
                        updatedTable4[4] = "0";
                        updatedTable4[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[3][3] = "0";
                        initialTable[3][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                    case "5":
                        updatedTable5[5] = "0";
                        updatedTable5[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[4][4] = "0";
                        initialTable[4][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                    case "6":
                        updatedTable6[6] = "0";
                        updatedTable6[Integer.parseInt(dataRow[1])] = dataRow[2];
                        
                        initialTable[5][5] = "0";
                        initialTable[5][Integer.parseInt(dataRow[1])-1] = dataRow[2];
                        break;
                }
                //System.out.print(dataRow[1]);
                switch (dataRow[1]) {
                    case "1":
                        updatedTable1[1] = "0";
                        updatedTable1[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[0][0] = "0";
                        initialTable[0][Integer.parseInt(dataRow[0]) -1] = dataRow[2];
                        break;
                    case "2":
                        updatedTable2[2] = "0";
                        updatedTable2[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[1][1] = "0";
                        initialTable[1][Integer.parseInt(dataRow[0])-1] = dataRow[2];
                        break;
                    case "3":
                        updatedTable3[3] = "0";
                        updatedTable3[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[2][2] = "0";
                        initialTable[2][Integer.parseInt(dataRow[0])-1] = dataRow[2];
                        break;
                    case "4":
                        updatedTable4[4] = "0";
                        updatedTable4[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[3][3] = "0";
                        initialTable[3][Integer.parseInt(dataRow[0])-1] = dataRow[2];
                        break;
                    case "5":
                        updatedTable5[5] = "0";
                        updatedTable5[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[4][4] = "0";
                        initialTable[4][Integer.parseInt(dataRow[0])-1] = dataRow[2];
                        break;
                    case "6":
                        updatedTable6[6] = "0";
                        updatedTable6[Integer.parseInt(dataRow[0])] = dataRow[2];
                        
                        initialTable[5][5] = "0";
                        initialTable[5][Integer.parseInt(dataRow[0])-1] = dataRow[2];
                        break;
                }
            }

        
        System.out.println("\na"  +updatedTables[0][0]);
        System.out.println("b" +initialTable[1][0]);
    }
    
    public void populate_neighbours(){
        int j;
        int i;
        neighbours = new ArrayList<>(row); 
        for (i = 0; i < row; i++) {
            neighbours.add(new ArrayList<>());
        }
        System.out.println();
        for (i =0; i<row; i++){
            for (j=0; j<originalData.length; j++){
                //System.out.println(Integer.parseInt((String)originalData[j][1]));
                if (Integer.parseInt((String)originalData[j][0]) == (i+1) ){
                    neighbours.get(i).add(Integer.parseInt((String)originalData[j][1]));
                    System.out.println("node" + (i+1) + (String)originalData[j][1]);
                }
                if (Integer.parseInt((String)originalData[j][1]) == (i+1) ){
                    neighbours.get(i).add(Integer.parseInt((String)originalData[j][0]));
                    System.out.println("node" + (i+1) + (String)originalData[j][0]);
                }
            }
            System.out.println();
        }
        
    }
    
    public void dvr(){
        int node, dest, i;
        int cost = 0;
        int dist = 0;
        
        initial = 0;
        long startTime = System.currentTimeMillis();
        //synchronized (this){
        System.out.println("Initial Table");
        for (i =0; i<initialTable.length; i++){
            for(int j=0; j<initialTable[0].length; j++){
                System.out.print(initialTable[i][j]);
            }
            System.out.println();
        }
        
        for (node=0; node< row; node++){
            count++;
            for (dest =1; dest<= row; dest++){
                bellmanFord = new ArrayList<Integer>();
                if((node + 1) == dest){
                       System.out.println("Here" + (node+1) + dest);
                       bellmanFord.add(0); 
                       
                    }
                count++;
                
                for (i=0; i< neighbours.get(node).size(); i++){
                    System.out.print("node " + node);
                    System.out.print(" neighbour " + neighbours.get(node).get(i));
                    cost = Integer.parseInt((String)updatedTables[node][neighbours.get(node).get(i)]);
                    System.out.println("cost " + cost);
                    //dist = Integer.parseInt((String)originalData[neighbours.get(node).get(i)][dest]);
                    //distance(dest, node, i);
                    dist = Integer.parseInt((String)initialTable[neighbours.get(node).get(i) -1][dest-1]);
                    System.out.print(" neighbour " + (neighbours.get(node).get(i)-1));
                    System.out.print("dest " + (dest-1));
                    System.out.println(" dist " + dist);
                    bellmanFord.add(cost + dist);
                    System.out.println();
                    System.out.println();
                }
                
                int min = Collections.min(bellmanFord);
                updatedTables[node][dest] = Integer.toString(min);
                System.out.println("min" + min);
                
            }   
        }
        DefaultTableModel model = (DefaultTableModel)jTable1.getModel();
        model.setRowCount(0);    //clears the table to assemble the new information of each node
        for (int k=0; k< row; k++){
                model.addRow(updatedTables[k]);
            }
        long stopTime = System.currentTimeMillis();
        String message = "Simulation has attained a stable state\n Elapsed time was " + (stopTime - startTime) + " miliseconds.";
        JOptionPane.showMessageDialog(null, message, "Run time", JOptionPane.INFORMATION_MESSAGE);
    }

    public int distance(int dest, int node, int i){
        int dist = 0;
        int tempNode;
        if ((neighbours.get(node).get(i)) == (dest-1)){
            return 0;
        }
        
        tempNode = neighbours.get(node).get(i); //5
        while(tempNode != dest){
            for (int j=0; j< neighbours.get(node).size(); i++){
                if (neighbours.get(tempNode).get(j) != node){
                    tempNode = neighbours.get(node).get(i); 
                }
                    
            }
        }
       // for (int j=0; j< neighbours.get(node).size(); i++){
            
            //if()
            dist = Integer.parseInt((String)initialTable[neighbours.get(node).get(i) -1][dest-1]);
       // }
        
        return dist;
    }
  
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Tables_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Tables_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Tables_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Tables_GUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                    new Tables_GUI().setVisible(true);
                    
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Tables_GUI.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(Tables_GUI.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }
    //private javax.swing.JMenuItem jMenuItem2;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem Node1;
    private javax.swing.JMenuItem Node2;
    private javax.swing.JMenuItem Node3;
    private javax.swing.JMenuItem Node4;
    private javax.swing.JMenuItem Node5;
    private javax.swing.JMenuItem Node6;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JButton loadTable;
    private javax.swing.JMenu nodeMenu;
    private javax.swing.JButton run;
    private javax.swing.JButton stepBystep;
    // End of variables declaration//GEN-END:variables
}



